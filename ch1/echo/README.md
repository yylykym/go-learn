# 命令行参数
os 包以跨平台的方式，提供了一些与操作系统交互的函数和变量。
程序的命令行参数可从 os 包的 Args 变量获取；os 包外部使用 `os.Args` 访问该变量。

os.Args 变量是一个字符串（string）的 切片（slice），
切片是 Go 语言的基础概念。
现在先把切片 s 当作数组元素序列，序列的长度动态变化，用 s[i] 访问单个元素 ，用 s[m:n] 获取子序列。
序列的元素数目为 len(s)。和大多数编程语言类似，区间索引时，Go 语言里也采用左闭右开形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。（比如 `a=[1,2,3,4,5]`, `a[0:3]=[1,2,3]`，不包含最后一个元素）。
比如 `s[m:n]` 这个切片，`0≤m≤n≤len(s)`，包含 n-m 个元素。

os.Args 的第一个元素：os.Args[0]，是命令本身的名字；其它的元素则是程序启动时传给它的参数。
s[m:n] 形式的切片表达式，产生从第 m 个元素到第 n-1 个元素的切片，下个例子用到的元素包含在 os.Args[1:len(os.Args)] 切片中。如果省略切片表达式的 m 或 n，会默认传入 0 或 len(s)，因此前面的切片可以简写成 os.Args[1:]。

# 代码分析
`var s, sep string` 定义两个变量 变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的 零值（zero value），数值类型是 0，字符串类型是空字符串 ""。

`sep + os.Args[i]` 表示连接字符串 `sep` 和 `os.Args[i]`。程序中使用的语句：`s+=sep+os.Args[i]` 是一条 赋值语句，将 `s` 的旧值跟 `sep` 与 `os.Args[i]` 连接后赋值回` s`，等价于：`s=s+sep+os.Args[i]`。

符号 `:=` 是 短变量声明 定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。

自增语句 i++ 给 i 加 1；这和 i+=1 以及 i=i+1 都是等价的。对应的还有 i-- 给 i 减 1。

它们是语句，而不像 C 系的其它语言那样是表达式。所以 j=i++ 非法，而且 ++ 和 -- 都只能放在变量名后面，因此 --i 也非法。

## for

Go 语言只有 for 循环这一种循环语句。for 循环有多种形式
```go
for initialization; condition; post {
    // zero or more statements
}
```
for 循环三个部分不需括号包围。大括号强制要求，左大括号必须和 post 语句在同一行。
initialization 语句是可选的，在循环开始前执行。initalization 如果存在，必须是一条 简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。condition 是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。
如果为 true 则执行循环体语句。post 语句在循环体执行结束后执行，之后再次对 condition 求值。
condition 值为 false 时，循环结束。

for 循环的这三个部分每个都可以省略，如果省略 initialization 和 post，分号也可以省略：
```go
// a traditional "while" loop
for condition {
    // ...
}
```

如果连 condition 也省略了，像下面这样：

```go
// a traditional infinite loop
for {
    // ...
}
```

这就变成一个无限循环

## range
for 循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。echo 的第二版本展示了这种形式 每次循环迭代，range 产生一对值；索引以及在该索引处的元素值。

这个例子不需要索引，但 range 的语法要求，要处理元素，必须处理索引。一种思路是把索引赋值给一个临时变量（如 temp）然后忽略它的值，但 Go 语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。

Go 语言中这种情况的解决方法是用 空标识符（blank identifier），即 _（也就是下划线）。空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。大多数的 Go 程序员都会像上面这样使用 range 和 _ 写 echo 程序，因为隐式地而非显式地索引 os.Args，容易写对。

## strings
每次循环迭代字符串 s 的内容都会更新。+= 连接原字符串、空格和下个参数，产生新字符串，并把它赋值给 s。s 原来的内容已经不再使用，将在适当时机对它进行垃圾回收。

如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用 strings 包的 Join 函数：如echo第三版